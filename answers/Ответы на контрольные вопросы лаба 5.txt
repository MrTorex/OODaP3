1. В чем различие между последовательными, ассоциативными и адаптерами контейнерами? Приведите примеры использования каждой категории контейнеров в проекте.

- Последовательные контейнеры: эти контейнеры хранят элементы в определённом порядке, который зависит от порядка их добавления. Примеры: vector, deque, list. Эти контейнеры обеспечивают возможность доступа к элементам по индексу и могут хранить дубликаты. Пример использования: vector часто используется для хранения динамических массивов данных в проектах, где важен произвольный доступ к элементам по индексу, например, для хранения списка студентов;

- Ассоциативные контейнеры: эти контейнеры хранят элементы в виде ключ-значение, а порядок элементов определяется не их порядком вставки, а значениями ключей (в порядке возрастания). Примеры: map, set. Ассоциативные контейнеры не допускают дубликаты ключей. Пример использования: map используется для хранения пар значений, например, имени пользователя и его идентификатора в системе, когда важна уникальность ключей и быстрый доступ по ним;

- Адаптеры контейнеров: это контейнеры, которые реализуют определенные структуры данных (например, стек, очередь), используя другие контейнеры как основу. Примеры: stack, queue, priority_queue. Они ограничивают интерфейс базового контейнера, предоставляя только нужные операции. Пример использования: stack можно использовать для реализации обратной обработки данных, например, выполнения рекурсивных функций или отката изменений.

2. Опишите основные характеристики и пример использования контейнера stack.

Основные характеристики:
- Контейнер stack реализует структуру данных по принципу LIFO (Last In, First Out — последним пришел, первым вышел);
- Он поддерживает операции добавления элемента в вершину стека, удаления верхнего элемента и доступа к верхнему элементу без его удаления;
- По умолчанию реализован на основе контейнера deque.

Пример использования: стек можно использовать для организации обработки вызовов функций, хранения состояния для возврата назад при работе с рекурсией или откатах (undo).

Пример:

#include <stack>
#include <iostream>
using namespace std;

int main() {
    stack<int> stk;
    stk.push(10);
    stk.push(20);
    cout << "Top element: " << stk.top() << endl; // Выведет 20
    stk.pop();
    cout << "Top element after pop: " << stk.top() << endl; // Выведет 10
    return 0;
}

3. Опишите основные характеристики и пример использования контейнера queue.

Основные характеристики:
- Контейнер queue реализует структуру данных по принципу FIFO (First In, First Out — первым пришел, первым вышел);
- Он поддерживает добавление элемента в конец очереди и извлечение элемента из начала очереди;
- Очередь может быть реализована на основе deque или list.

Пример использования: очередь используется для обработки данных в порядке поступления, например, в системе обработки заявок пользователей, где важно, чтобы запросы обрабатывались в том порядке, в котором они поступили.

Пример:

#include <queue>
#include <iostream>
using namespace std;

int main() {
    queue<int> q;
    q.push(10);
    q.push(20);
    cout << "Front element: " << q.front() << endl; // Выведет 10
    q.pop();
    cout << "Front element after pop: " << q.front() << endl; // Выведет 20
    return 0;
}

4. Опишите основные характеристики и пример использования контейнера priority_queue.

Основные характеристики:
- Контейнер priority_queue также реализует структуру данных по принципу FIFO, но с учетом приоритета элементов;
- Элемент с наивысшим приоритетом всегда оказывается первым;
- По умолчанию используется контейнер vector для хранения данных;

Пример использования: очередь с приоритетом может быть полезна при планировании задач, где задачи с наивысшим приоритетом должны выполняться первыми. Например, планировщик задач операционной системы.

Пример:

#include <queue>
#include <iostream>
using namespace std;

int main() {
    priority_queue<int> pq;
    pq.push(10);
    pq.push(20);
    pq.push(15);
    cout << "Top element: " << pq.top() << endl; // Выведет 20
    pq.pop();
    cout << "Top element after pop: " << pq.top() << endl; // Выведет 15
    return 0;
}

5. Опишите и приведите примеры использования основных методов контейнера stack.

- empty() — проверяет, пуст ли стек.
- push(const Type& val) — добавляет элемент в стек.
- pop() — удаляет элемент с вершины стека.
- top() — возвращает элемент на вершине стека без его удаления.
- size() — возвращает количество элементов в стеке.

Пример использования:

stack<int> stk;
stk.push(10);
stk.push(20);
cout << "Top element: " << stk.top() << endl; // Выведет 20
stk.pop();
cout << "Stack size: " << stk.size() << endl; // Выведет 1

6. Опишите и приведите примеры использования основных методов контейнера queue.

- empty() — проверяет, пуста ли очередь.
- push(const Type& val) — добавляет элемент в конец очереди.
- pop() — удаляет элемент из начала очереди.
- front() — возвращает первый элемент без его удаления.
- back() — возвращает последний элемент без его удаления.
- size() — возвращает количество элементов в очереди.

Пример использования:

queue<int> q;
q.push(10);
q.push(20);
cout << "Front element: " << q.front() << endl; // Выведет 10
cout << "Back element: " << q.back() << endl; // Выведет 20
q.pop();
cout << "Queue size: " << q.size() << endl; // Выведет 1

7. Опишите и приведите примеры использования основных методов контейнера priority_queue.

- empty() — проверяет, пуста ли очередь.
- push(const Type& val) — добавляет элемент в очередь с приоритетом.
- pop() — удаляет элемент с наивысшим приоритетом.
- top() — возвращает элемент с наивысшим приоритетом без его удаления.
- size() — возвращает количество элементов в очереди.

Пример использования:

priority_queue<int> pq;
pq.push(10);
pq.push(20);
pq.push(15);
cout << "Top element: " << pq.top() << endl; // Выведет 20
pq.pop();
cout << "Priority queue size: " << pq.size() << endl; // Выведет 2

8. В чем различие между контейнерами vector и list?

vector:
- Хранит элементы в непрерывной области памяти;
- Обеспечивает быстрый произвольный доступ по индексу;
- Добавление или удаление элементов в середине или начале требует перемещения элементов, что может быть медленным.

list:
- Хранит элементы как двусвязный список;
- Не поддерживает доступ по индексу — требуется последовательный доступ;
- Добавление и удаление элементов в любой части списка происходит быстро, так как не требует перемещения элементов.

9. В чем различие между контейнерами array и vector?

array:
- Имеет фиксированный размер, который должен быть известен на этапе компиляции;
- Не поддерживает динамическое изменение размера.

vector:
- Имеет динамический размер, который можно изменять во время выполнения программы;
- Может автоматически расширяться по мере добавления новых элементов.

10. В чем различие между контейнерами queue, stack, priority_queue?

queue: реализует принцип FIFO — элементы добавляются в конец и извлекаются из начала.

stack: реализует принцип LIFO — элементы добавляются и извлекаются с одного конца (вершины).

priority_queue: реализует принцип FIFO, но с приоритетом элементов — элемент с наивысшим приоритетом извлекается первым.